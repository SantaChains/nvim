# 键位无响应问题

<cite>
**本文档引用的文件**
- [keybindings.lua](file://lua/config/keybindings.lua)
- [which-key.lua](file://lua/plugins/which-key.lua)
- [init.lua](file://init.lua)
- [init_optimized.lua](file://lua/core/init_optimized.lua)
- [keymaps.lua](file://lua/config/keymaps.lua)
</cite>

## 目录
1. [问题概述](#问题概述)
2. [常见原因分析](#常见原因分析)
3. [诊断方法](#诊断方法)
4. [冲突解决机制](#冲突解决机制)
5. [Which-Key 配置验证](#which-key-配置验证)
6. [重载配置命令](#重载配置命令)
7. [最小化配置排查](#最小化配置排查)
8. [总结](#总结)

## 问题概述
Neovim 键位无响应是常见的配置问题，通常由前缀键冲突、插件加载顺序不当、模式映射覆盖等因素引起。本指南系统性地解释键位失效的可能原因，并提供完整的排查与解决方案。

**Section sources**
- [keybindings.lua](file://lua/config/keybindings.lua#L1-L20)
- [init.lua](file://init.lua#L1-L10)

## 常见原因分析

### 前缀键冲突
当多个插件或配置文件尝试注册相同的前缀键（如 `<leader>g`）时，后加载的配置会覆盖先前的定义，导致部分功能无法访问。

### Which-Key 未正确加载
由于 `which-key.nvim` 使用 `event = "VeryLazy"` 延迟加载机制，若在插件加载前查询键位，将无法看到其注册的提示组。

### 模式映射覆盖
不同模式（普通、插入、可视）下的键位可能相互覆盖。例如，全局映射可能被特定模式下的新定义替代。

### 插件初始化顺序问题
LazyVim 的异步加载机制可能导致某些键位在插件完全初始化前被设置，从而被后续插件重置。

**Section sources**
- [which-key.lua](file://lua/plugins/which-key.lua#L1-L10)
- [keybindings.lua](file://lua/config/keybindings.lua#L1-L30)

## 诊断方法

### 使用 `:verbose map` 追踪键位来源
Neovim 内置的 `:verbose map <key>` 命令可显示指定键位的定义位置及上下文。

```vim
:verbose map <leader>l
```
该命令将输出类似信息：
```
n  <leader>l       @<SNR>123_LspMap..
        Last set from ~/nvim/lua/config/keybindings.lua
```

### 自定义键位查看命令
配置中已定义多个实用命令用于诊断：

- `:ShowAllKeymaps`：显示所有模式的键位映射
- `:ShowLeaderKeymaps`：仅显示 `<leader>` 开头的键位
- `:CheckKeymapConflicts`：检查是否存在重复映射

这些命令帮助用户快速识别冲突和覆盖情况。

**Section sources**
- [keybindings.lua](file://lua/config/keybindings.lua#L145-L279)
- [init_optimized.lua](file://lua/core/init_optimized.lua#L100-L120)

## 冲突解决机制

### 统一管理键位定义
所有键位映射集中在 `keybindings.lua` 文件中进行管理，避免分散定义导致的冲突。

### 清理旧键位
在重新定义前，使用 `safe_unmap` 函数清理可能存在的旧映射：

```lua
local function safe_unmap(mode, key)
  pcall(vim.keymap.del, mode, key)
end
```

此机制确保新映射不会与残留旧映射发生冲突。

### 功能迁移与前缀重构
为解决冲突，部分功能已迁移至新前缀：
- LSP 功能从 `g` 系列迁移到 `<leader>l`
- 诊断功能从 `<leader>x` 迁移到 `<leader>d`
- 游戏功能从 `<leader>gol` 迁移到 `<leader>G`

**Section sources**
- [keybindings.lua](file://lua/config/keybindings.lua#L50-L140)

## Which-Key 配置验证

### 延迟加载确保插件可用
`which-key` 的组定义通过 `vim.schedule` 延迟执行，确保插件已加载：

```lua
vim.schedule(function()
  local ok, wk = pcall(require, "which-key")
  if not ok then return end
  wk.add({ ... })
end)
```

### 统一注册所有组
所有 which-key 组在单次 `wk.add()` 调用中注册，避免重复添加导致的性能损耗和逻辑混乱。

### 过滤潜在冲突键
在 `which-key.lua` 中通过 `filter` 函数排除易冲突的单字母键（如 `g`, `s`, `gr`, `gc`），防止干扰原生 Vim 操作。

**Diagram sources**
- [keybindings.lua](file://lua/config/keybindings.lua#L145-L180)
- [which-key.lua](file://lua/plugins/which-key.lua#L10-L30)

```mermaid
flowchart TD
A[启动 Neovim] --> B[执行 init.lua]
B --> C[加载 config.keybindings]
C --> D[尝试设置键位]
D --> E[which-key 尚未加载]
E --> F[vim.schedule 延迟执行]
F --> G[插件系统加载 which-key]
G --> H[执行 wk.add()]
H --> I[成功注册所有组]
```

**Section sources**
- [init.lua](file://init.lua#L1-L15)
- [keybindings.lua](file://lua/config/keybindings.lua#L145-L180)
- [which-key.lua](file://lua/plugins/which-key.lua#L1-L56)

## 重载配置命令

### 重新加载配置
执行 `:ReloadConfig` 命令可重新加载整个配置：

```lua
vim.api.nvim_create_user_command('ReloadConfig', function()
    vim.cmd('source $MYVIMRC')
    vim.notify('配置已重新加载', vim.log.levels.INFO)
end, { desc = '重新加载配置' })
```

### 其他调试命令
- `:CleanPlugins`：清理未使用的插件
- `:HealthCheck`：运行健康检查
- `:FixConflicts`：修复插件冲突
- `:ShowMappings`：显示当前键位映射

这些命令均在 `init_optimized.lua` 中定义，便于快速诊断和恢复。

**Section sources**
- [init_optimized.lua](file://lua/core/init_optimized.lua#L95-L143)
- [init.lua](file://init.lua#L1-L15)

## 最小化配置排查

### 排除第三方干扰
当遇到难以定位的键位问题时，建议采用最小化配置法：

1. 临时重命名 `~/.config/nvim` 为备份
2. 使用纯净的 LazyVim starter 配置
3. 逐步恢复自定义模块以定位冲突源

### 关键文件加载顺序
当前配置确保关键模块按正确顺序加载：

```lua
require("config.lazy")
vim.g.lazyvim_check_order = false
require("config.keybindings")
```

此顺序保证插件管理器先初始化，再应用自定义键位。

**Section sources**
- [init.lua](file://init.lua#L1-L15)
- [init_optimized.lua](file://lua/core/init_optimized.lua#L1-L50)

## 总结
键位无响应问题可通过系统性排查解决。核心策略包括：使用 `:verbose map` 定位定义源、验证 `which-key` 是否正常注册、利用内置诊断命令检查冲突、必要时重载配置或使用最小化配置法隔离问题。通过集中管理键位、合理规划前缀、确保加载顺序，可有效预防此类问题。

**Section sources**
- [keybindings.lua](file://lua/config/keybindings.lua#L1-L281)
- [which-key.lua](file://lua/plugins/which-key.lua#L1-L56)
- [init.lua](file://init.lua#L1-L50)